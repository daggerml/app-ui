(ns daggerml.cells
  (:require
    [cljs.core    :as cljs]
    [clojure.set  :as set]
    [clojure.walk :as walk]))

(defn- extract-syms
  "Extract symbols that will be bound by bindings, including autogenerated
  symbols produced for destructuring."
  [bindings]
  (map first (partition 2 (cljs/destructure bindings))))

(defn- extract-syms-without-autogen
  "Extract only the symbols that the user is binding from bindings, omitting
  any intermediate autogenerated bindings used for destructuring. A trick is
  used here taking advantage of the fact that gensym names are produced as a
  side effect -- successive calls to extract-syms are not redundant."
  [bindings]
  (let [syms1 (set (extract-syms bindings))
        syms2 (set (extract-syms bindings))]
    (seq (set/intersection syms1 syms2))))

(defn- bind-syms
  "Given a binding form, returns a seq of the symbols that will be bound.
  (bind-syms '[{:keys [foo some.ns/bar] :as baz} baf & quux])
  ;=> (foo bar baz baf quux)"
  [form]
  (extract-syms-without-autogen [form nil]))

(defn- get-derefs
  [expr]
  (let [derefs (atom #{})
        deref? #(and (seq? %) (= `deref (first %)) (symbol? (second %)))]
    (walk/prewalk (fn [x] (when (deref? x) (swap! derefs conj (second x))) x) expr)
    @derefs))

(defmacro with-let
  [[name value & bindings] & body]
  `(let [v# ~value, ~name v#, ~@bindings] ~@body v#))

(defmacro ^:private cell-let-1
  [[bindings c] & body]
  (let [syms  (bind-syms bindings)
        dcell `(formula [~c] #(let [~bindings (deref ~c)] [~@syms]))]
    `(let [[~@syms] (cell-map identity ~dcell)] ~@body)))

(defmacro cell-let
  [[bindings c & more] & body]
  (if-not (seq more)
    `(cell-let-1 [~bindings ~c] ~@body)
    `(cell-let-1 [~bindings ~c] (cell-let ~(vec more) ~@body))))

(defmacro cell=
  [expr & [setter]]
  (let [srcs (get-derefs (walk/macroexpand-all expr))]
    `(formula [~@srcs] (fn [] ~expr) ~setter)))

(defmacro watch=
  [c & body]
  `(do-watch ~c (fn [_# _#] ~@body)))

(defmacro defc
  ([name state]
   `(def ~name (cell ~state)))
  ([name doc state]
   `(def ~name ~doc (cell ~state))))

(defmacro defc=
  ([name expr]
   `(def ~name (cell= ~expr)))
  ([name doc-or-expr expr-or-setter]
   (if (string? doc-or-expr)
     `(def ~name ~doc-or-expr (cell= ~expr-or-setter))
     `(def ~name (cell= ~doc-or-expr ~expr-or-setter))))
  ([name doc expr setter]
   `(def ~name ~doc (cell= ~expr ~setter))))
